<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Layout Editor (Polygon Support)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #2d2d2d; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        
        .resizer {
            width: 5px; cursor: col-resize; background-color: #333;
            border-left: 1px solid #1a1a1a; border-right: 1px solid #1a1a1a;
            z-index: 10;
        }
        .resizer:hover, .resizer.active { background-color: #007acc; }

        #canvas-wrapper { 
            background-color: #1e1e1e;
            background-image: 
                linear-gradient(#333 1px, transparent 1px),
                linear-gradient(90deg, #333 1px, transparent 1px);
        }

        .tab-active { background-color: #1e1e1e !important; border-top: 2px solid #007acc !important; color: white !important; }
        .layer-tab-active { background-color: #3e3e42 !important; font-weight: bold; border-bottom: 2px solid #ffcc00; }
        
        .input-dark {
            background-color: #3c3c3c; border: 1px solid #555; 
            border-radius: 2px; padding: 2px 6px; color: white; width: 100%;
        }
        
        .select-dark {
            background-color: #3c3c3c; border: 1px solid #555; 
            border-radius: 2px; padding: 2px 6px; color: white; font-size: 12px;
        }

        /* Modal Style */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 9999;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-window {
            width: 90%; height: 90%; background: #1e1e1e; border: 1px solid #454545;
            display: flex; flex-direction: column; color: #ccc;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 select-none">

    <div id="app" class="flex h-full w-full">
        
        <!-- 1. 좌측 뷰포트 영역 -->
        <div class="flex flex-col h-full relative" :style="{ width: `calc(100% - ${sidebarWidth}px)` }">
            
            <!-- 상단 툴바 -->
            <div class="h-10 bg-[#2d2d2d] border-b border-[#1a1a1a] flex items-center px-4 gap-4 text-xs">
                <div class="flex items-center gap-2">
                    <span class="text-gray-400 font-bold">Unit:</span>
                    <select v-model="currentUnitKey" @change="changeUnitSystem" class="select-dark">
                        <option value="mks">MKS (Meters)</option>
                        <option value="mmgs">MMGS (Millimeters)</option>
                        <option value="ips">IPS (Inches)</option>
                    </select>
                </div>
                <div class="w-[1px] h-4 bg-gray-600"></div>
                <div class="flex items-center gap-2">
                    <span class="text-gray-400">Grid:</span>
                    <input type="number" v-model.number="gridSize" :step="currentUnit.step" class="w-16 input-dark text-center">
                    <span class="text-gray-500">{{ currentUnit.label }}</span>
                </div>
                <div class="w-[1px] h-4 bg-gray-600"></div>
                <div class="flex items-center gap-2">
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" v-model="snapEnabled"> 
                        <span>Snapping</span>
                    </label>
                </div>
                <div class="flex-1 text-right text-gray-500">
                    Main Editor
                </div>
            </div>

            <!-- 캔버스 영역 -->
            <div id="canvas-wrapper" class="flex-1 relative overflow-hidden" 
                 :style="gridStyle"
                 @contextmenu.prevent>
                <canvas id="c"></canvas>
            </div>

            <!-- 하단 레이어 탭 -->
            <div class="h-8 bg-[#2d2d2d] flex items-center border-t border-[#1a1a1a] px-2 text-xs overflow-x-auto">
                <div v-for="layer in layers" :key="layer.id"
                     @click="setActiveLayer(layer.id)"
                     class="px-4 h-full flex items-center cursor-pointer hover:bg-[#3e3e42] gap-2 transition-colors whitespace-nowrap"
                     :class="{ 'layer-tab-active': activeLayerId === layer.id, 'opacity-50': !layer.visible }"
                     :style="{ borderLeft: `4px solid ${layer.color}` }">
                    <span>{{ layer.name }}</span>
                    <i class="fa-solid fa-eye ml-2 hover:text-white" 
                       :class="layer.visible ? 'text-gray-400' : 'text-gray-600'"
                       @click.stop="toggleLayerVisibility(layer.id)"></i>
                </div>
            </div>
        </div>

        <!-- 2. 리사이저 핸들 -->
        <div class="resizer" @mousedown="startResize"></div>

        <!-- 3. 우측 툴바 & 인스펙터 -->
        <div class="bg-[#252526] flex flex-col border-l border-black" :style="{ width: `${sidebarWidth}px` }">
            
            <div class="flex h-9 bg-[#2d2d2d] text-xs">
                <button @click="currentTab = 'inspector'" class="flex-1 flex items-center justify-center gap-2 hover:bg-[#1e1e1e]" :class="{ 'tab-active': currentTab === 'inspector' }">
                    <i class="fa-solid fa-circle-info"></i> Inspector
                </button>
                <button @click="currentTab = 'library'" class="flex-1 flex items-center justify-center gap-2 hover:bg-[#1e1e1e]" :class="{ 'tab-active': currentTab === 'library' }">
                    <i class="fa-solid fa-cubes"></i> Library
                </button>
            </div>

            <div class="p-4 flex-1 overflow-y-auto">
                <!-- A. 인스펙터 탭 -->
                <div v-if="currentTab === 'inspector'">
                    <div v-if="selectedObject" class="space-y-4">
                        <h3 class="font-bold text-sm text-white mb-2 pb-1 border-b border-gray-600">PROPERTIES ({{ currentUnit.name }})</h3>
                        <div class="grid grid-cols-2 gap-3 text-xs">
                            <div>
                                <label class="block mb-1 text-gray-400">Position X</label>
                                <input type="number" :value="toUnit(props.left)" @input="e => updateProp('left', e.target.value)" :step="currentUnit.step" class="input-dark">
                            </div>
                            <div>
                                <label class="block mb-1 text-gray-400">Position Y</label>
                                <input type="number" :value="toUnit(props.top)" @input="e => updateProp('top', e.target.value)" :step="currentUnit.step" class="input-dark">
                            </div>
                            <div>
                                <label class="block mb-1 text-gray-400">Rotation (°)</label>
                                <input type="number" v-model.number="props.angle" @input="updateObject" class="input-dark">
                            </div>
                        </div>
                    </div>
                    <div v-else class="text-center text-gray-500 text-sm mt-10">
                        <p>No object selected</p>
                    </div>
                </div>

                <!-- B. 라이브러리 탭 -->
                <div v-else class="flex flex-col h-full">
                    <div class="mb-4 space-y-2">
                        <input type="text" placeholder="Search models..." class="input-dark text-xs p-2">
                        <button @click="openModelerModal" class="w-full bg-[#007acc] hover:bg-[#0062a3] text-white py-1 px-2 rounded text-xs flex items-center justify-center gap-2 transition">
                            <i class="fa-solid fa-plus"></i> Create New Model
                        </button>
                    </div>

                    <div class="flex-1 overflow-y-auto space-y-2">
                        <div v-for="i in 3" :key="i" class="bg-[#3c3c3c] hover:bg-[#505050] p-2 rounded cursor-pointer flex items-center gap-3 transition group">
                            <div class="w-10 h-10 bg-gray-800 border border-gray-600 flex items-center justify-center">
                                <i class="fa-solid fa-cube text-gray-500"></i>
                            </div>
                            <div class="flex-1">
                                <div class="text-xs font-bold text-gray-200">Custom Robot V{{i}}</div>
                                <div class="text-[10px] text-gray-400">Updated 2h ago</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!--  MODAL: Parametric Model Builder             -->
        <!-- ============================================ -->
        <div v-if="showModal" class="modal-overlay">
            <div class="modal-window">
                
                <!-- 1. Header -->
                <div class="h-10 bg-[#2d2d2d] border-b border-[#454545] flex items-center px-4 justify-between">
                    <span class="font-bold text-sm"><i class="fa-solid fa-pen-ruler mr-2"></i>Parametric Model Builder</span>
                    <div class="flex gap-2">
                        <button @click="saveModel" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs">Save to Library</button>
                        <button @click="closeModelerModal" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-xs">Close</button>
                    </div>
                </div>

                <div class="flex flex-1 overflow-hidden">
                    
                    <!-- 2. Modal Toolbar -->
                    <div class="w-14 bg-[#333] border-r border-[#454545] flex flex-col items-center py-2 gap-2">
                        <button @click="addModalRect" title="Rectangle" class="w-10 h-10 hover:bg-[#505050] rounded flex items-center justify-center"><i class="fa-regular fa-square"></i></button>
                        <button @click="addModalCircle" title="Circle" class="w-10 h-10 hover:bg-[#505050] rounded flex items-center justify-center"><i class="fa-regular fa-circle"></i></button>
                        
                        <!-- NEW: Polygon Button -->
                        <button @click="addModalPolygon" title="Regular Polygon" class="w-10 h-10 hover:bg-[#505050] rounded flex items-center justify-center relative">
                            <i class="fa-solid fa-draw-polygon"></i>
                            <div class="absolute bottom-0 right-0 text-[8px] bg-blue-500 px-1 rounded-sm text-white">N</div>
                        </button>
                        
                        <div class="w-8 h-[1px] bg-gray-600 my-1"></div>
                        <button title="Smart Dimension (Visual Only)" class="w-10 h-10 bg-[#007acc] text-white rounded flex items-center justify-center"><i class="fa-solid fa-ruler-combined"></i></button>
                    </div>

                    <!-- 3. Modal Canvas -->
                    <div class="flex-1 relative bg-[#1e1e1e]" id="modal-canvas-wrapper">
                         <canvas id="modal-canvas"></canvas>
                    </div>

                    <!-- 4. Feature Tree / Properties -->
                    <div class="w-64 bg-[#252526] border-l border-[#454545] p-2 flex flex-col">
                        <h4 class="text-xs font-bold text-gray-400 mb-2 uppercase">Features & Parameters</h4>
                        <div class="flex-1 overflow-y-auto space-y-1">
                            
                            <div v-for="(obj, idx) in modalObjects" :key="idx" 
                                 @click="selectModalObject(obj)"
                                 class="p-2 bg-[#333] border border-transparent hover:border-[#007acc] text-xs rounded cursor-pointer transition-all"
                                 :class="{'border-[#007acc] bg-[#3e3e42]': modalSelectedObject === obj}">
                                
                                <div class="flex items-center gap-2 mb-2 font-bold text-gray-200">
                                    <i :class="getIconClass(obj.type)"></i>
                                    <span>{{ obj.type.charAt(0).toUpperCase() + obj.type.slice(1) }} {{ idx + 1 }}</span>
                                </div>

                                <!-- Parametric Inputs -->
                                <div class="grid grid-cols-2 gap-2 pl-2 border-l-2 border-gray-600 py-1">
                                    
                                    <!-- A. Polygon Parameters -->
                                    <template v-if="obj.type === 'polygon'">
                                        <div class="col-span-2 flex items-center justify-between">
                                            <label class="text-blue-400 font-bold">Sides:</label>
                                            <input type="number" min="3" v-model.number="obj.sides" @input="updateModalCanvas" class="bg-black border border-gray-500 w-20 px-1 text-right text-yellow-400 font-bold">
                                        </div>
                                        <div class="col-span-2 flex items-center justify-between">
                                            <label class="text-gray-400">Radius:</label>
                                            <input type="number" v-model.number="obj.radius" @input="updateModalCanvas" class="bg-black border border-gray-600 w-20 px-1 text-right">
                                        </div>
                                    </template>

                                    <!-- B. Rectangle Parameters -->
                                    <template v-if="obj.type === 'rect'">
                                        <div class="flex flex-col">
                                            <label class="text-[10px] text-gray-500">Width</label>
                                            <input type="number" v-model.number="obj.width" @input="updateModalCanvas" class="bg-black border border-gray-600 w-full px-1">
                                        </div>
                                        <div class="flex flex-col">
                                            <label class="text-[10px] text-gray-500">Height</label>
                                            <input type="number" v-model.number="obj.height" @input="updateModalCanvas" class="bg-black border border-gray-600 w-full px-1">
                                        </div>
                                    </template>

                                    <!-- C. Circle Parameters -->
                                    <template v-if="obj.type === 'circle'">
                                        <div class="col-span-2 flex items-center justify-between">
                                            <label class="text-gray-400">Radius:</label>
                                            <input type="number" v-model.number="obj.radius" @input="updateModalCanvas" class="bg-black border border-gray-600 w-20 px-1 text-right">
                                        </div>
                                    </template>

                                    <!-- Common Position -->
                                    <div class="col-span-2 pt-1 border-t border-gray-700 grid grid-cols-2 gap-2 mt-1">
                                        <div><span class="text-[10px] text-gray-500">X:</span> <input type="number" v-model.number="obj.left" @input="updateModalCanvas" class="bg-black border border-gray-600 w-16 px-1"></div>
                                        <div><span class="text-[10px] text-gray-500">Y:</span> <input type="number" v-model.number="obj.top" @input="updateModalCanvas" class="bg-black border border-gray-600 w-16 px-1"></div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, onMounted, computed, nextTick } = Vue;

        const UNIT_SYSTEMS = {
            mks:  { name: 'MKS (Meters)', label: 'm', step: 0.1, pixelsPerUnit: 100, defaultGrid: 0.5 },
            mmgs: { name: 'MMGS (Millimeters)', label: 'mm', step: 10, pixelsPerUnit: 1, defaultGrid: 500 },
            ips:  { name: 'IPS (Inches)', label: 'in', step: 1, pixelsPerUnit: 96, defaultGrid: 20 }
        };

        createApp({
            setup() {
                // Main Editor State
                const sidebarWidth = ref(300);
                const currentTab = ref('library');
                const canvas = ref(null);
                const selectedObject = ref(null);
                const currentUnitKey = ref('mks');
                const currentUnit = computed(() => UNIT_SYSTEMS[currentUnitKey.value]);
                const gridSize = ref(0.5);
                const zoomLevel = ref(1);
                const viewportTransform = ref([1, 0, 0, 1, 0, 0]);
                const snapEnabled = ref(true);
                const props = ref({ left: 0, top: 0, width: 0, angle: 0, fill: '#ffffff' });
                const layers = ref([
                    { id: 'amr', name: 'AMR', color: '#e74c3c', visible: true },
                    { id: 'main', name: 'Main Layout', color: '#3498db', visible: true },
                    { id: 'bg', name: 'Background', color: '#9b59b6', visible: true }
                ]);
                const activeLayerId = ref('main');

                // Modal State
                const showModal = ref(false);
                const modalCanvas = ref(null);
                const modalObjects = ref([]); 
                const modalSelectedObject = ref(null);

                // Helpers
                const toUnit = (px) => {
                    const val = px / currentUnit.value.pixelsPerUnit;
                    return currentUnitKey.value === 'mmgs' ? Math.round(val) : parseFloat(val.toFixed(3));
                };
                const toPx = (unitVal) => Math.round(parseFloat(unitVal) * currentUnit.value.pixelsPerUnit);

                const getIconClass = (type) => {
                    if(type === 'rect') return 'fa-regular fa-square text-blue-400';
                    if(type === 'circle') return 'fa-regular fa-circle text-red-400';
                    if(type === 'polygon') return 'fa-solid fa-draw-polygon text-yellow-400';
                    return 'fa-solid fa-vector-square';
                };

                const drawOriginMarker = (c) => {
                    const existings = c.getObjects().filter(o => o.isOrigin);
                    c.remove(...existings);
                    const lineOpts = { strokeWidth: 2, selectable: false, evented: false, isOrigin: true };
                    const xAxis = new fabric.Line([0, 0, 50, 0], { ...lineOpts, stroke: '#ff3333' });
                    const yAxis = new fabric.Line([0, 0, 0, 50], { ...lineOpts, stroke: '#33cc33' });
                    const originCircle = new fabric.Circle({ left: -4, top: -4, radius: 4, fill: '#fff', selectable: false, evented: false, isOrigin: true });
                    c.add(xAxis, yAxis, originCircle);
                };

                onMounted(() => {
                    initMainCanvas();
                });

                const initMainCanvas = () => {
                    canvas.value = new fabric.Canvas('c', {
                        backgroundColor: 'transparent',
                        width: window.innerWidth - sidebarWidth.value,
                        height: window.innerHeight - 32,
                        preserveObjectStacking: true
                    });
                    drawOriginMarker(canvas.value);

                    canvas.value.on('mouse:wheel', function(opt) {
                        const evt = opt.e;
                        evt.preventDefault(); evt.stopPropagation();
                        if (evt.altKey) {
                            let zoom = canvas.value.getZoom() * (0.999 ** evt.deltaY);
                            if (zoom > 20) zoom = 20; if (zoom < 0.05) zoom = 0.05;
                            canvas.value.zoomToPoint({ x: evt.offsetX, y: evt.offsetY }, zoom);
                            zoomLevel.value = zoom;
                            viewportTransform.value = canvas.value.viewportTransform;
                        } else {
                            const vpt = canvas.value.viewportTransform;
                            vpt[4] -= evt.deltaX; vpt[5] -= evt.deltaY;
                            canvas.value.requestRenderAll();
                            viewportTransform.value = [...vpt];
                        }
                    });
                    
                    canvas.value.on('selection:created', updateState);
                    canvas.value.on('selection:updated', updateState);
                    canvas.value.on('selection:cleared', () => selectedObject.value = null);
                    canvas.value.on('object:modified', updateState);
                    canvas.value.on('object:moving', (options) => {
                         if (!snapEnabled.value) return;
                         const snapPx = gridSize.value * currentUnit.value.pixelsPerUnit;
                         options.target.left = Math.round(options.target.left / snapPx) * snapPx;
                         options.target.top = Math.round(options.target.top / snapPx) * snapPx;
                    });
                };

                const changeUnitSystem = () => {
                    gridSize.value = currentUnit.value.defaultGrid;
                    canvas.value.requestRenderAll();
                    if(selectedObject.value) updateState();
                };

                // --- Modal Functions ---
                const openModelerModal = () => {
                    showModal.value = true;
                    modalObjects.value = [];
                    nextTick(() => { initModalCanvas(); });
                };
                const closeModelerModal = () => {
                    showModal.value = false;
                    if (modalCanvas.value) { modalCanvas.value.dispose(); modalCanvas.value = null; }
                };

                const initModalCanvas = () => {
                    const wrapper = document.getElementById('modal-canvas-wrapper');
                    modalCanvas.value = new fabric.Canvas('modal-canvas', {
                        width: wrapper.clientWidth, height: wrapper.clientHeight,
                        backgroundColor: '#252526', selection: true
                    });

                    modalCanvas.value.on('selection:created', (e) => {
                        const active = e.selected[0];
                        if(active) modalSelectedObject.value = active.dataRef; 
                    });
                    modalCanvas.value.on('selection:updated', (e) => {
                         const active = e.selected[0];
                         if(active) modalSelectedObject.value = active.dataRef;
                    });
                    
                    modalCanvas.value.on('object:modified', (e) => {
                        const target = e.target;
                        if(target.dataRef) {
                            target.dataRef.left = Math.round(target.left);
                            target.dataRef.top = Math.round(target.top);
                            if(target.dataRef.type === 'rect') {
                                target.dataRef.width = Math.round(target.width * target.scaleX);
                                target.dataRef.height = Math.round(target.height * target.scaleY);
                            } else if(target.dataRef.type === 'circle') {
                                target.dataRef.radius = Math.round(target.radius * target.scaleX);
                            } else if(target.dataRef.type === 'polygon') {
                                target.dataRef.radius = Math.round(target.width * target.scaleX / 2); // 근사치 업데이트
                            }
                            updateModalCanvas(); 
                        }
                    });
                };

                const addModalRect = () => {
                    modalObjects.value.push({ type: 'rect', left: 50, top: 50, width: 100, height: 100 });
                    renderModalObjects();
                };
                const addModalCircle = () => {
                    modalObjects.value.push({ type: 'circle', left: 200, top: 50, radius: 50 });
                    renderModalObjects();
                };
                
                // --- POLYGON LOGIC ---
                const addModalPolygon = () => {
                    // 기본값: 육각형(sides: 6)
                    modalObjects.value.push({ type: 'polygon', left: 300, top: 100, radius: 50, sides: 6 });
                    renderModalObjects();
                };

                // 정다각형 좌표 계산 함수
                const getRegularPolygonPoints = (sides, radius) => {
                    const points = [];
                    for (let i = 0; i < sides; i++) {
                        // -90도(상단)부터 시작
                        const angle = (i * 2 * Math.PI / sides) - (Math.PI / 2);
                        points.push({
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle)
                        });
                    }
                    return points;
                };

                const renderModalObjects = () => {
                    if(!modalCanvas.value) return;
                    modalCanvas.value.clear();
                    modalCanvas.value.backgroundColor = '#252526';

                    // Modal Grid Lines
                    new fabric.Line([0, -2000, 0, 2000], { stroke: '#333', selectable: false }).set({ left: 0, top: 0 });
                    new fabric.Line([-2000, 0, 2000, 0], { stroke: '#333', selectable: false }).set({ left: 0, top: 0 });

                    modalObjects.value.forEach(data => {
                        let obj;
                        if(data.type === 'rect') {
                            obj = new fabric.Rect({
                                left: data.left, top: data.top,
                                width: data.width, height: data.height,
                                fill: '#3498db', stroke: 'white', strokeWidth: 1, opacity: 0.8
                            });
                        } else if(data.type === 'circle') {
                            obj = new fabric.Circle({
                                left: data.left, top: data.top,
                                radius: data.radius,
                                fill: '#e74c3c', stroke: 'white', strokeWidth: 1, opacity: 0.8
                            });
                        } else if(data.type === 'polygon') {
                            // sides 입력값에 따라 동적으로 points 생성
                            const points = getRegularPolygonPoints(data.sides, data.radius);
                            obj = new fabric.Polygon(points, {
                                left: data.left, top: data.top,
                                fill: '#f1c40f', stroke: 'white', strokeWidth: 1, opacity: 0.8
                            });
                        }
                        
                        obj.dataRef = data;
                        modalCanvas.value.add(obj);

                        if(modalSelectedObject.value === data) {
                            modalCanvas.value.setActiveObject(obj);
                        }
                    });
                    modalCanvas.value.renderAll();
                };

                const updateModalCanvas = () => { renderModalObjects(); };
                const selectModalObject = (obj) => { modalSelectedObject.value = obj; renderModalObjects(); };

                const saveModel = () => {
                    if(modalObjects.value.length === 0) return;
                    // 메인 캔버스에 그룹으로 복사
                    const objects = modalObjects.value.map(data => {
                        if(data.type === 'rect') {
                            return new fabric.Rect({ left: data.left, top: data.top, width: data.width, height: data.height, fill: '#3498db' });
                        } else if(data.type === 'polygon') {
                             const points = getRegularPolygonPoints(data.sides, data.radius);
                             return new fabric.Polygon(points, { left: data.left, top: data.top, fill: '#f1c40f' });
                        } else {
                            return new fabric.Circle({ left: data.left, top: data.top, radius: data.radius, fill: '#e74c3c' });
                        }
                    });
                    const group = new fabric.Group(objects, { left: 100, top: 100, subTargetCheck: true });
                    canvas.value.add(group);
                    canvas.value.setActiveObject(group);
                    canvas.value.requestRenderAll();
                    closeModelerModal();
                    alert("Model saved to Library (InMemory) & Added to Canvas");
                };

                const gridStyle = computed(() => {
                    const zoom = zoomLevel.value;
                    const panX = viewportTransform.value[4];
                    const panY = viewportTransform.value[5];
                    const sizePx = gridSize.value * currentUnit.value.pixelsPerUnit * zoom; 
                    return {
                        backgroundSize: `${sizePx}px ${sizePx}px`,
                        backgroundPosition: `${panX}px ${panY}px`
                    };
                });

                const isResizing = ref(false);
                const startResize = () => { isResizing.value = true; };
                window.addEventListener('mousemove', (e) => {
                    if (isResizing.value) sidebarWidth.value = Math.max(200, Math.min(600, window.innerWidth - e.clientX));
                });
                window.addEventListener('mouseup', () => {
                    if(isResizing.value) {
                        isResizing.value = false;
                        canvas.value.setDimensions({ width: window.innerWidth - sidebarWidth.value, height: window.innerHeight - 32 });
                    }
                });

                const updateState = () => {
                    const activeObj = canvas.value.getActiveObject();
                    if (activeObj && activeObj.type !== 'activeSelection') {
                        selectedObject.value = activeObj;
                        props.value = {
                            left: activeObj.left, top: activeObj.top,
                            width: (activeObj.width || 0) * activeObj.scaleX,
                            angle: activeObj.angle, fill: activeObj.fill
                        };
                        currentTab.value = 'inspector';
                    } else { selectedObject.value = null; }
                };

                const updateProp = (key, userValue) => {
                    const pxValue = toPx(userValue);
                    props.value[key] = pxValue; 
                    updateObject(); 
                };

                const updateObject = () => {
                    const activeObj = canvas.value.getActiveObject();
                    if (!activeObj) return;
                    activeObj.set({ left: props.value.left, top: props.value.top, angle: props.value.angle });
                    canvas.value.renderAll();
                };
                const setActiveLayer = (id) => activeLayerId.value = id;
                const toggleLayerVisibility = (id) => { /* 생략 (이전과 동일) */ };

                return {
                    sidebarWidth, currentTab, layers, activeLayerId, selectedObject, props,
                    gridSize, snapEnabled, zoomLevel, gridStyle,
                    currentUnitKey, currentUnit, changeUnitSystem,
                    startResize, updateProp, updateObject, setActiveLayer, toggleLayerVisibility, toUnit,
                    // Modal
                    showModal, openModelerModal, closeModelerModal, 
                    addModalRect, addModalCircle, addModalPolygon,
                    modalObjects, modalSelectedObject, selectModalObject, updateModalCanvas, saveModel, getIconClass
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
